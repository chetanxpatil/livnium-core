import 'package:livnium_core/livnium_core.dart';
import 'package:test/test.dart';

/// Tests for Physics Exploits and Thermodynamic Policy fixes.
/// Exploits: Vampire Effect, Rubik's Parity, Memorization Basin, Entropy Death.
/// Policies: Minimum Mass, Tunneling Operator, Antipodal Noise.
void main() {
  group('1. Vampire Effect (Minimum Mass Law)', () {
    test('enforceMinimumMass raises cells below floor before renormalization',
        () {
      final state = LatticeState(3);
      state.cells[5].swEffective = 0.01 * state.cells[5].swBase;
      enforceMinimumMass(state, fraction: 0.10);
      expect(state.cells[5].swEffective,
          greaterThanOrEqualTo(0.10 * state.cells[5].swBase - 1e-9));
    });

    test(
        'with Minimum Mass Law: no cell below 10% of base weight after basin updates',
        () {
      final state = LatticeState(3);
      for (var i = 0; i < 10; i++) state.cells[i].active = true;
      final constants = BasinConstants(
        minimumMassFraction: 0.10,
        useAntipodalNoise: false,
      );
      for (var i = 0; i < 50; i++) {
        updateBasinGeometry(state, i.isEven, constants: constants);
      }
      for (final cell in state.cells) {
        expect(
          cell.swEffective,
          greaterThanOrEqualTo(0.10 * cell.swBase - 1e-9),
          reason: 'cell ${cell.coord}',
        );
      }
      expect(auditConservation(state), isTrue);
    });
  });

  group('2. Rubik\'s Parity (Tunneling Operator)', () {
    test('adjacent cells are face-neighbors only', () {
      final n = 3;
      expect(areAdjacent(LatticeCoord(n, 0, 0, 0), LatticeCoord(n, 1, 0, 0)),
          isTrue);
      expect(areAdjacent(LatticeCoord(n, 0, 0, 0), LatticeCoord(n, 0, 1, 0)),
          isTrue);
      expect(areAdjacent(LatticeCoord(n, 0, 0, 0), LatticeCoord(n, 1, 1, 0)),
          isFalse);
    });

    test(
        'tunnelingSwap swaps two adjacent cells, applies cost, and renormalizes',
        () {
      final state = LatticeState(3);
      final c1 = state.cellAt(0, 0, 0);
      final c2 = state.cellAt(1, 0, 0);
      final sw1Before = c1.swEffective;
      final sw2Before = c2.swEffective;
      final ok = tunnelingSwap(
        state,
        LatticeCoord(3, 0, 0, 0),
        LatticeCoord(3, 1, 0, 0),
        costFactor: 0.95,
      );
      expect(ok, isTrue);
      expect(state.totalEffectiveWeight, closeTo(totalEnergySymbolic(3), 1e-9));
      expect(auditConservation(state), isTrue);
      expect(c1.swEffective, isNot(closeTo(sw1Before, 1e-6)),
          reason: 'swap occurred');
      expect(c2.swEffective, isNot(closeTo(sw2Before, 1e-6)),
          reason: 'swap occurred');
    });

    test('tunnelingSwap rejects non-adjacent cells', () {
      final state = LatticeState(3);
      final ok = tunnelingSwap(
        state,
        LatticeCoord(3, 0, 0, 0),
        LatticeCoord(3, 2, 2, 2),
      );
      expect(ok, isFalse);
    });
  });

  group('3. Entropy Death (Antipodal Noise)', () {
    test('antipodal permutation preserves total weight', () {
      final state = LatticeState(3);
      final before = state.totalEffectiveWeight;
      applyAntipodalNoise(state);
      expect(state.totalEffectiveWeight, closeTo(before, 1e-10));
    });

    test('antipodal is inversion: applying twice restores (permutation)', () {
      final state = LatticeState(3);
      final snapshot = state.cells.map((c) => c.swEffective).toList();
      applyAntipodalNoise(state);
      applyAntipodalNoise(state);
      for (var i = 0; i < state.cells.length; i++) {
        expect(state.cells[i].swEffective, closeTo(snapshot[i], 1e-10));
      }
    });

    test('update with useAntipodalNoise: true still conserves', () {
      final state = LatticeState(3);
      state.cells[0].active = true;
      updateBasinGeometry(state, false,
          constants: BasinConstants(useAntipodalNoise: true));
      expect(state.totalEffectiveWeight, closeTo(totalEnergySymbolic(3), 1e-8));
      expect(auditConservation(state), isTrue);
    });
  });

  group('4. All policies together', () {
    test('basin update with default constants (all policies on) conserves', () {
      final state = LatticeState(5);
      for (var i = 0; i < 20; i++) {
        state.cells[i % state.length].active = true;
        updateBasinGeometry(state, i.isEven);
      }
      expect(auditConservation(state), isTrue);
      for (final cell in state.cells) {
        expect(
            cell.swEffective, greaterThanOrEqualTo(0.10 * cell.swBase - 1e-9));
      }
    });
  });
}
